(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{425:function(t,e,v){"use strict";v.r(e);var n=v(1),r=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("hr"),t._v(" "),e("h2",{attrs:{id:"一、概述和分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、概述和分类"}},[t._v("#")]),t._v(" 一、概述和分类")]),t._v(" "),e("ol",[e("li",[t._v("介绍\n"),e("ul",[e("li",[t._v("IO：输入输出")]),t._v(" "),e("li",[t._v("流：抽象概念，对数据传输的总称。")]),t._v(" "),e("li",[t._v("IO流就是用来处理数据传输问题的。")])])]),t._v(" "),e("li",[t._v("分类\n"),e("ul",[e("li",[t._v("按照数据的流向\n"),e("ul",[e("li",[t._v("输入流")]),t._v(" "),e("li",[t._v("输出流")])])]),t._v(" "),e("li",[t._v("按照数据类型\n"),e("ul",[e("li",[t._v("字节流")]),t._v(" "),e("li",[t._v("字符流")])])])])]),t._v(" "),e("li",[t._v("使用场景\n"),e("ul",[e("li",[t._v("文本文件：字符流")]),t._v(" "),e("li",[t._v("图片、音频等二进制文件：字节流")]),t._v(" "),e("li",[t._v("不确定文件：字节流")])])])]),t._v(" "),e("h2",{attrs:{id:"二、字节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、字节流"}},[t._v("#")]),t._v(" 二、字节流")]),t._v(" "),e("ol",[e("li",[t._v("字节流抽象基类\n"),e("ul",[e("li",[t._v("InputStream：是所有输入流的超类")]),t._v(" "),e("li",[t._v("OutputStream：是所有输出流的超类")]),t._v(" "),e("li",[t._v("子类名都是以父类名作为后缀的")])])]),t._v(" "),e("li",[t._v("使用字节输出流写数据的步骤\n"),e("ul",[e("li",[t._v("创建字节输出流对象(调用系统功能创建文件，让自己输出流对象指向文件)")]),t._v(" "),e("li",[t._v("调用字节输出流对象的写数据方法")]),t._v(" "),e("li",[t._v("释放资源")])])]),t._v(" "),e("li",[t._v("一些方法\n"),e("ul",[e("li",[t._v("字节输出流\n"),e("ul",[e("li",[t._v("构造方法：\n"),e("ul",[e("li",[e("strong",[t._v("FileOutputStream(String name)")]),t._v("\n创建文件输出流以指定的名称写入文件。 将创建一个新的FileDescriptor对象来表示此文件连接。")]),t._v(" "),e("li",[e("strong",[t._v("FileOutputStream(File file)")]),t._v("\n创建文件输出流以写入指定的File对象表示的文件。")]),t._v(" "),e("li",[e("strong",[t._v("FileOutputStream(File file, boolean append)")]),t._v("\n创建文件输出流以写入由指定的。第二个boolean若为true则写入文件的末尾而不是开头。")]),t._v(" "),e("li",[e("strong",[t._v("FileOutputStream(FileDescriptor fdObj)")]),t._v("\n创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。")]),t._v(" "),e("li",[e("strong",[t._v("FileOutputStream")]),t._v("(FileDescriptor fdObj)\n创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。")])])]),t._v(" "),e("li",[e("strong",[t._v("void close()")]),t._v("\n关闭输出流并释放资源")]),t._v(" "),e("li",[e("strong",[t._v("FileChannel getChannel()")]),t._v("\n返回此文件输出流相关联的唯一的FileChannel对象")]),t._v(" "),e("li",[e("strong",[t._v("FileDescriptor getFD()")]),t._v("\n返回此流相关的文件描述符。in,out,err")]),t._v(" "),e("li",[t._v("write\n"),e("ul",[e("li",[e("strong",[t._v("void write(byte[] b)")]),t._v("\n将 b.length字节从指定的字节数组写入此文件输出流。")]),t._v(" "),e("li",[e("strong",[t._v("void write(byte[] b, int off, int len)")]),t._v("\n将 len字节从指定的字节数组开始，从偏移量 off开始写入此文件输出流。")]),t._v(" "),e("li",[e("strong",[t._v("void write(int b)")]),t._v("\n将指定的字节写入此文件输出流。")])])])])]),t._v(" "),e("li",[t._v("字节输入流\n"),e("ul",[e("li",[t._v("构造方法\n"),e("ul",[e("li",[e("strong",[t._v("FileInputStream(File file)")]),t._v("\n通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的File对象 file命名。")]),t._v(" "),e("li",[e("strong",[t._v("FileInputStream(FileDescriptor fdObj)")]),t._v("\n通过使用文件描述符 fdObj创建 FileInputStream ，该文件描述符表示与文件系统中的实际文件的现有连接。\n由于文本描述符对象是每个文件独有的，所有获得的输入流对象实际上是来自那个文件的。")]),t._v(" "),e("li",[e("strong",[t._v("FileInputStream(String name)")]),t._v("\n通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。")])])]),t._v(" "),e("li",[e("strong",[t._v("int available()")]),t._v("\n返回从此输入流中可以读取（或跳过）的剩余字节数的估计值，而不会被下一次调用此输入流的方法阻塞。")]),t._v(" "),e("li",[e("strong",[t._v("void close()")]),t._v("\n关闭此文件输入流并释放资源")]),t._v(" "),e("li",[e("strong",[t._v("FileChannel getChannel()")])]),t._v(" "),e("li",[e("strong",[t._v("FileDescriptor getFD()")])]),t._v(" "),e("li",[t._v("read\n"),e("ul",[e("li",[e("strong",[t._v("int read()")]),t._v("\n从该输入流读取一个字节的数据。")]),t._v(" "),e("li",[e("strong",[t._v("int read(byte[] b)")]),t._v("\n从该输入流读取最多 b.length个字节的数据到一个字节数组。")]),t._v(" "),e("li",[e("strong",[t._v("int read(byte[] b, int off, int len)")]),t._v("\n从该输入流读取最多 len个字节的数据到字节数组。")])])]),t._v(" "),e("li",[e("strong",[t._v("long skip(long n)")]),t._v("\n跳过并从输入流中丢弃 n字节的数据。")])])])])])]),t._v(" "),e("h2",{attrs:{id:"三、字节缓冲流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、字节缓冲流"}},[t._v("#")]),t._v(" 三、字节缓冲流")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("BufferOutputStream")]),t._v("\n该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用。")]),t._v(" "),e("li",[e("strong",[t._v("BufferedInputStream")]),t._v("\n创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节。")])]),t._v(" "),e("h2",{attrs:{id:"四、字符流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、字符流"}},[t._v("#")]),t._v(" 四、字符流")]),t._v(" "),e("ol",[e("li",[t._v("介绍\n字符流 = 字节流 + 编码表")]),t._v(" "),e("li",[t._v("编码解码方法\n"),e("ul",[e("li",[e("strong",[t._v("byte[] getBytes()")]),t._v("\n使用平台的默认字符集将该 String编码为一系列字节")]),t._v(" "),e("li",[e("strong",[t._v("byte[] getBytes(String charsetName)")]),t._v("\n使用指定的字符集将该 String编码为一系列字节")]),t._v(" "),e("li",[e("strong",[t._v("String(byte[] bytes)")]),t._v("\n使用平台的默认字符集解码指定的字节数组来创建字符串")]),t._v(" "),e("li",[e("strong",[t._v("String(byte[] bytes, String charsetName)")]),t._v("\n通过指定的字符集解码指定的字节数组来创建字符串")])])]),t._v(" "),e("li",[t._v("字符流的编码解码\n"),e("ul",[e("li",[t._v("InputStreamReader：从字节流到字符流的桥梁，将字节编码为字符，编码可以由名称指定，也可以明确指定，也可以默认")]),t._v(" "),e("li",[t._v("OutputStreamWriter：是从字符流到字节流的桥梁")])])]),t._v(" "),e("li",[t._v("方法\n"),e("ol",[e("li",[t._v("InputStreamReader\n"),e("ul",[e("li",[t._v("构造方法\n"),e("ul",[e("li",[e("strong",[t._v("InputStreamReader(InputStream in)")]),t._v("\n创建一个使用默认字符集的InputStreamReader")]),t._v(" "),e("li",[e("strong",[t._v("InputStreamReader(InputStream in, String charsetName)")]),t._v("\n创建一个使用命名字符集的InputStreamReader。")]),t._v(" "),e("li",[e("strong",[t._v("InputStreamReader(InputStream in, Charset cs)")]),t._v("\n创建一个使用给定字符集的InputStreamReader。")]),t._v(" "),e("li",[e("strong",[t._v("InputStreamReader(InputStream in, CharsetDecoder dec)")]),t._v(" 创建一个使用给定字符集解码器的InputStreamReader。")])])]),t._v(" "),e("li",[e("strong",[t._v("void close()")]),t._v("\n关闭流并释放资源")]),t._v(" "),e("li",[e("strong",[t._v("String getEncoding()")]),t._v("\n返回此流使用的字符编码的名称。")]),t._v(" "),e("li",[e("strong",[t._v("int read()")]),t._v("\n读一个字符")]),t._v(" "),e("li",[e("strong",[t._v("int read(char[] cbuf,int offset,int length)")]),t._v("\n将字符读入数组的一部分")]),t._v(" "),e("li",[e("strong",[t._v("boolean ready()")]),t._v(" 流是否可以被读取")])])]),t._v(" "),e("li",[t._v("OutputStreamWriter\n"),e("ul",[e("li",[t._v("构造方法\n"),e("ul",[e("li",[e("strong",[t._v("OutputStreamWriter(OutputStream out)")]),t._v("\n创建一个使用默认字符编码的OutputStreamWriter。")]),t._v(" "),e("li",[e("strong",[t._v("OutputStreamWriter(OutputStream out, String charsetName)")]),t._v("\n创建一个使用命名字符集的OutputStreamWriter。")]),t._v(" "),e("li",[e("strong",[t._v("OutputStreamWriter(OutputStream out, Charset cs)")]),t._v("\n创建一个使用给定字符集的OutputStreamWriter。")]),t._v(" "),e("li",[e("strong",[t._v("OutputStreamWriter(OutputStream out, CharsetEncoder enc)")]),t._v("\n创建一个使用给定字符集编码器的OutputStreamWriter。")])])]),t._v(" "),e("li",[e("strong",[t._v("Writer append(CharSequence csq)")]),t._v("\n将指定的字符序列附加到此作者。")]),t._v(" "),e("li",[e("strong",[t._v("Writer append(CharSequence csq, int start, int end)")]),t._v("\n将指定字符序列的子序列附加到此作者。")]),t._v(" "),e("li",[e("strong",[t._v("void close()")]),t._v("\n关闭流")]),t._v(" "),e("li",[e("strong",[t._v("void flush()")]),t._v("\n刷新流")]),t._v(" "),e("li",[e("strong",[t._v("String getEncoding()")]),t._v("\n返回此流使用的字符编码的名称。")]),t._v(" "),e("li",[e("strong",[t._v("void write(char[] cbuf, int off, int len)")]),t._v("\n写入字符数组的一部分。")]),t._v(" "),e("li",[e("strong",[t._v("void write(int c)")]),t._v("\n写一个字符")])])])])])]),t._v(" "),e("h2",{attrs:{id:"五、字符缓冲流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、字符缓冲流"}},[t._v("#")]),t._v(" 五、字符缓冲流")]),t._v(" "),e("ol",[e("li",[t._v("BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途。")]),t._v(" "),e("li",[t._v("BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途。")]),t._v(" "),e("li",[t._v("构造方法\n"),e("ul",[e("li",[t._v("**BufferedWriter(Writer out)**创建字符缓冲输出流对象")]),t._v(" "),e("li",[t._v("**BufferedReader(Reader in)**创建字符缓冲输入流对象")]),t._v(" "),e("li",[t._v("其他写入，刷新，关闭方法同字符流一致")]),t._v(" "),e("li",[e("strong",[t._v("void newLine()")]),t._v("\n写一行行分隔符，行分隔符字符串由系统属性定义")]),t._v(" "),e("li",[e("strong",[t._v("String readLine()")]),t._v("\n读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);